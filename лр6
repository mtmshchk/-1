#Задание состоит из двух частей.
1 часть – написать программу в соответствии со своим вариантом задания. 
Написать 2 варианта формирования (алгоритмический и с помощью функций Питона), сравнив по времени их выполнение.
2 часть – усложнить написанную программу, введя по своему усмотрению в условие 
минимум одно ограничение на характеристики объектов (которое будет сокращать количество переборов) 
и целевую функцию для нахождения оптимального решения.

#вариант 26: Вводятся К целых чисел. Составьте все возможные различные правильные дроби из этих чисел

import timeit
from itertools import combinations

# Ввод чисел с ограничением
def input_numbers():
    nums = list(map(int, input("Введите целые числа через пробел: ").split()))
    return nums

# Измерение времени выполнения функции
def measure_time(func, *args):
    start_time = timeit.default_timer()  # начальное время
    result = func(*args)  # Вызываем функцию с переданными аргументами
    end_time = timeit.default_timer()  # Засекаем конечное время
    execution_time = end_time - start_time  # Вычисляем время выполнения
    return result, execution_time  # Возвращаем результат функции и время выполнения

# Алгоритмический подход для создания дробей
def algorithmic_approach(nums):
    fractions = set()
    for pair in combinations(nums, 2):  # Создаем все возможные комбинации пар чисел
        fraction = pair[0] / pair[1]  # Вычисляем дробь
        fractions.add(fraction)  # Добавляем дробь в множество
    return fractions  # Возвращаем множество дробей

# Функциональный подход с использованием itertools
def functional_approach(nums):
    fractions = set()
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):  # Создаем все возможные комбинации пар чисел
            fraction = nums[i] / nums[j]  # Вычисляем дробь
            fractions.add(fraction)  # Добавляем дробь в множество
    return fractions  # Возвращаем множество дробей

# Усложненный алгоритмический подход (кратные 5)
def complex_algorithmic_approach(nums):
    fractions = set()
    max_multiple_of_5 = find_max_multiple_of_5(nums)  # Находим максимальное число, кратное 5
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] % 5 == 0:  # Проверяем, кратно ли числитель 5
                fraction = nums[i] * nums[j]  # Вычисляем дробь
                fractions.add(fraction)  # Добавляем дробь в множество
            elif nums[j] % 5 == 0:  # Проверяем, кратен ли знаменатель 5
                fraction = nums[j] * nums[i]  # Вычисляем дробь
                fractions.add(fraction)  # Добавляем дробь в множество
    return fractions, max_multiple_of_5  # Возвращаем множество дробей и максимальное число кратное 5

# Усложненный функциональный подход (itertools, кратные 5)
def complex_functional_approach(nums):
    fractions = set()
    max_multiple_of_5 = find_max_multiple_of_5(nums)  # Находим максимальное число, кратное 5
    for pair in combinations(nums, 2):  # Создаем все возможные комбинации пар чисел
        if pair[0] % 5 == 0:  # Проверяем, кратно ли числитель 5
            fraction = pair[0] * pair[1]  # Вычисляем дробь
            fractions.add(fraction)  # Добавляем дробь в множество
        elif pair[1] % 5 == 0:  # Проверяем, кратно ли знаменатель 5
            fraction = pair[1] * pair[0]  # Вычисляем дробь
            fractions.add(fraction)  # Добавляем дробь в множество
    return fractions, max_multiple_of_5  # Возвращаем множество дробей и максимальное число кратное 5

# Поиск максимального числа, кратного 5
def find_max_multiple_of_5(nums):
    max_multiple = float('-inf')  # Инициализируем переменную для максимального числа кратного 5
    for num in nums:
        if num % 5 == 0 and num > max_multiple:  # Проверяем, кратно ли число 5 и больше ли оно текущего максимального
            max_multiple = num 
    return max_multiple

# Ввод чисел
nums = input_numbers()

# Выполнение и измерение времени для алгоритмического подхода
algorithmic_result, time_alg = measure_time(algorithmic_approach, nums)

# Выполнение и измерение времени для функционального подхода
functional_result, time_func = measure_time(functional_approach, nums)

# Выполнение и измерение времени для усложненного алгоритмического подхода
complex_algorithmic_result, time_complex_alg = measure_time(complex_algorithmic_approach, nums)

# Выполнение и измерение времени для усложненного функционального подхода
complex_functional_result, time_complex_func = measure_time(complex_functional_approach, nums)

# Вывод результатов
print("Алгоритмический подход:")
print(algorithmic_result)
print("Время выполнения: {:.6f} секунд".format(time_alg))

print("\nФункциональный подход (itertools):")
print(functional_result)
print("Время выполнения: {:.6f} секунд".format(time_func))

print("\nУсложненный алгоритмический подход (кратные 5):")
print(complex_algorithmic_result)
print("Время выполнения: {:.6f} секунд".format(time_complex_alg))

print("\nУсложненный функциональный подход (itertools, кратные 5):")
print(complex_functional_result)
print("Время выполнения: {:.6f} секунд".format(time_complex_func))
