#26.Формируется матрица F следующим образом: если в С количество нулей в нечетных столбцах в области 1 больше, 
#чем произведение чисел по периметру области 4, то поменять в С симметрично области 1 и 3 местами, 
#иначе В и Е поменять местами несимметрично. При этом матрица А не меняется. 
#После чего вычисляется выражение: ((К*A T)*(F+А-F).
#Выводятся по мере формирования А, F и все матричные операции последовательно.

def print_matrix(matrix): 
    for row in matrix: 
        print(' '.join(map(str, row))) 

def create_matrix_A(N):  #создание матрицы A
    A = [[0] * N for _ in range(N)]  #создание матрицы N x N, заполненной нулями
    for i in range(N): 
        for j in range(N):
            #определение элементов матрицы в зависимости от их положения в четырех областях
            if i < N // 2 and j < N // 2:  #область 1: левый верхний треугольник
                if j >= i:  #верхний треугольник
                    A[i][j] = 1
            elif i < N // 2 and j >= N // 2:  #область 2: верхний треугольник
                if j < i + N // 2:  #левый верхний треугольник
                    A[i][j] = 2
            elif i >= N // 2 and j >= N // 2:  #область 3: правый верхний треугольник
                if j < N - i - 1:  #верхний треугольник
                    A[i][j] = 3
            else:  #область 4: правый нижний треугольник
                if j >= N - i:  #нижний треугольник
                    A[i][j] = 4
    return A

def count_zeros_in_odd_columns(C):  #функция для подсчета нулей в нечетных столбцах матрицы C
    count = 0 
    for j in range(1, len(C[0]), 2):  #перебор нечетных столбцов матрицы
        for i in range(len(C)):  #перебор строк матрицы
            if C[i][j] == 0: 
                count += 1  
    return count 

def calculate_perimeter_product(C):  #функция для вычисления произведения элементов по периметру матрицы C
    perimeter_product = C[0][0] * C[0][-1] * C[-1][-1] * C[-1][0]  #вычисление произведения элементов
    return perimeter_product

def form_matrix_F(C):  #функция для формирования матрицы F на основе матрицы C
    F = [[elem for elem in row] for row in C]  #создание копии матрицы C
    zeros_count = count_zeros_in_odd_columns(C)  #подсчет количества нулей в нечетных столбцах
    perimeter_product = calculate_perimeter_product(C)  #вычисление произведения элементов по периметру
    if zeros_count > perimeter_product: 
        # Меняем элементы матрицы F симметрично между областями 1 и 3
        for i in range(len(F) // 2):  #перебор строк верхней половины матрицы
            for j in range(len(F[0]) // 2):  #перебор столбцов левой половины матрицы
                F[i][j], F[i + len(F) // 2][j + len(F[0]) // 2] = F[i + len(F) // 2][j + len(F[0]) // 2], F[i][j]
    else:  
        for i in range(len(F) // 2):  #перебор строк верхней половины матрицы
            for j in range(len(F[0]) // 2):  #перебор столбцов левой половины матрицы
                F[i][j + len(F[0]) // 2], F[i + len(F) // 2][j] = F[i + len(F) // 2][j], F[i][j + len(F[0]) // 2]
    return F 

def transpose_matrix(matrix):  #функция для транспонирования матрицы
    return [list(row) for row in zip(*matrix)]

def multiply_matrix_by_scalar(matrix, scalar):  #функция для умножения матрицы на скаляр
    return [[scalar * cell for cell in row] for row in matrix]

def matrix_addition(A, B):  #функция для сложения двух матриц
    return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))]

def matrix_multiplication(A, B):  #функция для умножения двух матриц
    result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))]  #создание матрицы-результата нулей
    for i in range(len(A)):  #перебор строк матрицы A
        for j in range(len(B[0])):  #перебор столбцов матрицы B
            for k in range(len(B)):  #перебор элементов по длине матрицы B
                result[i][j] += A[i][k] * B[k][j]  #вычисление произведения и суммирование
    return result 

def main():
    K = int(input("Введите число K: ")) 
    N = int(input("Введите размерность матрицы N (кратный 4): ")) 
    if N % 4 != 0: 
        print("N должно быть кратным 4.") 
        return 

    print("Матрица A:")  
    A = create_matrix_A(N)  #создание матрицы A
    print_matrix(A)  #вывод матрицы A
    F_sequence = []  #инициализация списка для последовательности матриц F
    C = create_matrix_A(N)  #создание матрицы C
    F = form_matrix_F(C)  #формирование матрицы F
    F_sequence.append(F)  #добавление матрицы F в последовательность
    KA_transpose_sequence = []  #инициализация списка для последовательности транспонированных матриц KA

    for i in range(N // 4):  #перебор отрезков длиной 4
        mid = N // 2  #определение середины матрицы
        B = [row[:mid] for row in A[:mid]]  #определение матриц BCDE
        C = [row[mid:] for row in A[:mid]]
        D = [row[:mid] for row in A[mid:]]
        E = [row[mid:] for row in A[mid:]]

        if count_zeros_in_odd_columns(C) > calculate_perimeter_product(E):  #если количество нулей в нечетных столбцах больше произведения элементов периметра
            for i in range(mid):
                for j in range(mid):
                    E[i][j], E[j][i] = E[j][i], E[i][j]  #обмен значениями элементов симметрично относительно центра матрицы
        else:  #иначе меняем значения матриц C и E местами
            C, E = E, C

        F = [B[i] + C[i] for i in range(mid)] + [D[i] + E[i] for i in range(mid)]  #объединение матриц B, C, D, E в матрицу F
        F_sequence.append(F)  #добавление матрицы F в последовательность

        KA = multiply_matrix_by_scalar(A, K)  #умножение матрицы A на скаляр K
        KA_transpose = transpose_matrix(KA)  #транспонирование матрицы KA
        KA_transpose_sequence.append(KA_transpose) #добавление транспонированной матрицы KA в последовательность

        A_squared = matrix_addition(matrix_addition(matrix_multiplication(A, A), A), A)  #возводим матрицу A в квадрат
        expression_result = matrix_multiplication(KA_transpose, matrix_addition(F, matrix_addition(A, multiply_matrix_by_scalar(F, -1))))  #вычисляем результат выражения

        print("Матрица F после преобразований:")
        print_matrix(F) 

        print("Матрица KA (K умноженное на A):") 
        print_matrix(KA) 

        print("Матрица A в квадрате:") 
        print_matrix(A_squared)

        print("Результат выражения ((К*A^T)*(F+А-F)):") 
        print_matrix(expression_result)

if __name__ == "__main__": 
    main() 
