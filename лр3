"""
Вариант 26. Формируется матрица F следующим образом: если в С количество нулей в нечетных столбцах 
в области 1 больше, чем произведение чисел по периметру области 4, 
то поменять в С симметрично области 1 и 3 местами, иначе В и Е поменять местами несимметрично. 
При этом матрица А не меняется. После чего вычисляется выражение: ((К*A T)*(F+А-F).
Выводятся по мере формирования А, F и все матричные операции последовательно.
"""

import random

def print_matrix(matrix):
    # Функция для вывода матрицы в виде строк
    for row in matrix:
        print(' '.join(map(str, row)))     print()

def create_matrix(N):
    # Функция для создания матрицы размером N x N с случайными значениями от -10 до 10
    A = [[random.randint(-10, 10) for _ in range(N)] for _ in range(N)]
    return A

def split_matrix(A, N):
    # Функция для разделения матрицы на четыре подматрицы: B, C, D, E
    half = N // 2
    B = [row[:half] for row in A[:half]]  # Подматрица B - левая верхняя четверть
    C = [row[half:] for row in A[:half]]  # Подматрица C - правая верхняя четверть
    D = [row[:half] for row in A[half:]]  # Подматрица D - левая нижняя четверть
    E = [row[half:] for row in A[half:]]  # Подматрица E - правая нижняя четверть
    return B, C, D, E

def extract_triangles(matrix):
    half = len(matrix)
    t1 = [matrix[i][:i + 1] for i in range(half)]  # Левый треугольник
    t2 = [matrix[i][i:] for i in range(half)]     # Верхний треугольник
    t3 = [matrix[i][:half - i] for i in range(half)]  # Правый треугольник
    t4 = [matrix[i][half - i - 1:] for i in range(half)]  # Нижний треугольник
    return t1, t2, t3, t4

def count_zeros_in_odd_columns(matrix):
    count = 0
    for row in matrix:
        for j in range(1, len(row), 2):  # Нечётные столбцы: 1, 3, 5, ...
            if row[j] == 0:
                count += 1
    return count

def product_of_perimeter(triangle):
    product = 1
    for row in triangle:
        for element in row:
            product *= element
    return product

def swap_matrices_symmetrically(B, C):
    return C, B

def swap_matrices_asymmetrically(B, E):
    return E, B

def combine_matrix(B, C, D, E, N):
    half = N // 2
    F = [[0] * N for _ in range(N)]
    for i in range(half):
        for j in range(half):
            F[i][j] = B[i][j]
            F[i][j + half] = D[i][j] 
            F[i + half][j] = C[i][j]  
            F[i + half][j + half] = E[i][j]
    return F

def matrix_inverse(matrix, N):
    # Реализуем метод Гаусса для нахождения обратной матрицы
    identity = [[1 if i == j else 0 for j in range(N)] for i in range(N)]
    for i in range(N):
        factor = matrix[i][i]
        if factor == 0:
            # Если элемент на главной диагонали равен нулю, переходим к следующей итерации
            continue
        for j in range(N):
            matrix[i][j] /= factor
            identity[i][j] /= factor
        for k in range(N):
            if k != i:
                factor = matrix[k][i]
                for j in range(N):
                    matrix[k][j] -= factor * matrix[i][j]
                    identity[k][j] -= factor * identity[i][j]
    return identity

def matrix_multiply(A, B, N):
    result = [[0] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            for k in range(N):
                result[i][j] += A[i][k] * B[k][j]
    return result

# Ввод данных
K = int(input("Введите значение K: "))
N = int(input("Введите значение N (четное число): "))

# Проверка, что N четное
if N % 2 != 0:
    raise ValueError("N должно быть четным числом.")

# Создание матрицы A
A = create_matrix(N)

# Вывод матрицы A
print("Матрица A:")
print_matrix(A)

# Разделение матрицы на подматрицы B, C, D, E
B, C, D, E = split_matrix(A, N)

# Извлечение треугольников из подматриц
B_t1, B_t2, B_t3, B_t4 = extract_triangles(B)
C_t1, C_t2, C_t3, C_t4 = extract_triangles(C)
D_t1, D_t2, D_t3, D_t4 = extract_triangles(D)
E_t1, E_t2, E_t3, E_t4 = extract_triangles(E)

# Подсчет количества нулей в нечётных столбцах верхнего треугольника подматрицы C
zeros_in_C_t2 = count_zeros_in_odd_columns(C_t2)

# Вычисление произведения чисел по периметру нижнего треугольника подматрицы E
perimeter_product_E_t4 = product_of_perimeter(E_t4)

# Формирование матрицы F в зависимости от условия
if zeros_in_C_t2 > perimeter_product_E_t4:
    B, C = swap_matrices_symmetrically(B, C)
else:
    B, E = swap_matrices_asymmetrically(B, E)

# Восстановление матрицы F из подматриц
F = combine_matrix(B, C, D, E, N)

# Вывод матриц B, C, D, E и F
print("Подматрица B:")
print_matrix(B)
print("Подматрица C:")
print_matrix(C)
print("Подматрица D:")
print_matrix(D)
print("Подматрица E:")
print_matrix(E)
print("Матрица F:")
print_matrix(F)

# Вычисление обратной матрицы A
A_inv = matrix_inverse(A, N)

# Вычисление выражения ((K * A^-1) * (F + A - F))
K_A_inv = [[K * A_inv[i][j] for j in range(N)] for i in range(N)]
result = matrix_multiply(K_A_inv, matrix_multiply(F, matrix_multiply(A, A_inv, N), N), N)

# Округление результатов до целых чисел
result = [[int(round(elem)) for elem in row] for row in result]

# Вывод результата
print("Результат выражения ((K * A^-1) * (F + A - F)):")
print_matrix(result)
